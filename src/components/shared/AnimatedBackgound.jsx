import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';


const fragmentShader = "// Fragment shader\n\n\n\n// Uniforms\n\nuniform vec2 u_resolution;\n\nuniform vec2 u_mouse;\n\nuniform float u_time;\n\nuniform float u_intensity;\n\nuniform vec4 u_colors[2];\n\nuniform float u_speed;\n\nuniform float u_scale;\n\n\n\nvarying vec2 vUv;\n\nvarying float vDisplacement;\n\n\n\n\n\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec2 permute(const in vec2 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec3 permute(const in vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(const in vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n#endif\n\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n\n#ifndef FNC_QUINTIC\n#define FNC_QUINTIC \n\nfloat quintic(const in float v) { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec2  quintic(const in vec2 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec3  quintic(const in vec3 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec4  quintic(const in vec4 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\n\n#endif\n\n\n\n#ifndef FNC_PNOISE\n#define FNC_PNOISE\n\nfloat pnoise(in vec2 P, in vec2 rep) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); \n    Pi = mod289(Pi);        \n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = quintic(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat pnoise(in vec3 P, in vec3 rep) {\n    vec3 Pi0 = mod(floor(P), rep); \n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); \n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); \n    vec3 Pf1 = Pf0 - vec3(1.0); \n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = quintic(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat pnoise(in vec4 P, in vec4 rep) {\n    vec4 Pi0 = mod(floor(P), rep); \n    vec4 Pi1 = mod(Pi0 + 1.0, rep); \n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); \n    vec4 Pf1 = Pf0 - 1.0; \n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = quintic(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n#endif\n\n\n\n\n\n\n#ifndef RANDOM_SCALE\n#if defined(RANDOM_HIGHER_RANGE)\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#if defined(RANDOM_SINLESS)\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#if defined(RANDOM_SINLESS)\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#if defined(RANDOM_SINLESS)\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#if defined(RANDOM_SINLESS)\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy+33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\n#endif\n\n\n    \n\nvoid main() {\n\n  float distort = vDisplacement * u_intensity;\n\n  vec2 val = abs(vUv - 0.5) * 3.0  * (1.0 - distort);\n\n  \n\n  vec4 color = vec4(vec3(val,u_colors[0].b),1.0);\n\n  color = mix(u_colors[0], u_colors[1], vDisplacement);\n\n  \n\n  \n\n  gl_FragColor = color;\n\n}\n\n";
const vertexShader = "//Geometry: plane\n\n//OrbitControls: false\n\n//Geometry-args: [1,1, 1024, 1024]\n\n//Mesh-scale: 50\n\n//camera-position: [0.0, 0.0, 24.0]\n\n\n\nuniform float u_intensity;\n\nuniform float u_time;\n\nuniform float u_speed;\n\nuniform bool u_rotate;\n\nuniform float u_scale;\n\n\n\nvarying vec2 vUv;\n\nvarying float vDisplacement;\n\n\n\n\n\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec2 permute(const in vec2 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec3 permute(const in vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(const in vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n#endif\n\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n\n#ifndef FNC_QUINTIC\n#define FNC_QUINTIC \n\nfloat quintic(const in float v) { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec2  quintic(const in vec2 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec3  quintic(const in vec3 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec4  quintic(const in vec4 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\n\n#endif\n\n\n\n#ifndef FNC_CNOISE\n#define FNC_CNOISE\n\nfloat cnoise(in vec2 P) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); \n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = quintic(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat cnoise(in vec3 P) {\n    vec3 Pi0 = floor(P); \n    vec3 Pi1 = Pi0 + vec3(1.0); \n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); \n    vec3 Pf1 = Pf0 - vec3(1.0); \n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = quintic(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat cnoise(in vec4 P) {\n    vec4 Pi0 = floor(P); \n    vec4 Pi1 = Pi0 + 1.0; \n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); \n    vec4 Pf1 = Pf0 - 1.0; \n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = quintic(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n#endif\n\n\n\n\n\n\n#ifndef RANDOM_SCALE\n#if defined(RANDOM_HIGHER_RANGE)\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#if defined(RANDOM_SINLESS)\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#if defined(RANDOM_SINLESS)\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#if defined(RANDOM_SINLESS)\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#if defined(RANDOM_SINLESS)\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy+33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\n#endif\n\n\n\n#ifndef FNC_SRANDOM\n#define FNC_SRANDOM\n\nfloat srandom(in float x) {\n  return -1. + 2. * fract(sin(x) * 43758.5453);\n}\n\nfloat srandom(in vec2 st) {\n  return -1. + 2. * fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat srandom(in vec3 pos) {\n  return -1. + 2. * fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfloat srandom(in vec4 pos) {\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return -1. + 2. * fract(sin(dot_product) * 43758.5453);\n}\n\nvec2 srandom2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec3 srandom3(in vec3 p) {\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(p) * 43758.5453123);\n}\n\nvec2 srandom2(in vec2 p, const in float tileLength) {\n    p = mod(p, vec2(tileLength));\n    return srandom2(p);\n}\n\nvec3 srandom3(in vec3 p, const in float tileLength) {\n    p = mod(p, vec3(tileLength));\n    return srandom3(p);\n}\n\n#endif\n\n\n#ifndef FNC_CUBIC\n#define FNC_CUBIC \nfloat cubic(const in float v) { return v*v*(3.0-2.0*v); }\nvec2  cubic(const in vec2 v)  { return v*v*(3.0-2.0*v); }\nvec3  cubic(const in vec3 v)  { return v*v*(3.0-2.0*v); }\nvec4  cubic(const in vec4 v)  { return v*v*(3.0-2.0*v); }\n\nfloat cubic(const in float value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    float value2 = value * value;\n    float value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n\nvec2 cubic(const in vec2 value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    vec2 value2 = value * value;\n    vec2 value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n\nvec3 cubic(const in vec3 value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    vec3 value2 = value * value;\n    vec3 value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n\nvec4 cubic(const in vec4 value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    vec4 value2 = value * value;\n    vec4 value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n#endif\n\n\n#ifndef FNC_QUINTIC\n#define FNC_QUINTIC \n\nfloat quintic(const in float v) { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec2  quintic(const in vec2 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec3  quintic(const in vec3 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec4  quintic(const in vec4 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\n\n#endif\n\n\n\n#ifndef FNC_GNOISE\n#define FNC_GNOISE\n\nfloat gnoise(float x) {\n    float i = floor(x);  \n    float f = fract(x);  \n    return mix(random(i), random(i + 1.0), smoothstep(0.,1.,f)); \n}\n\nfloat gnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = cubic(f);\n    return mix( a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n}\n\nfloat gnoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = quintic(f);\n    return -1.0 + 2.0 * mix( mix( mix( random(i + vec3(0.0,0.0,0.0)), \n                                        random(i + vec3(1.0,0.0,0.0)), u.x),\n                                mix( random(i + vec3(0.0,1.0,0.0)), \n                                        random(i + vec3(1.0,1.0,0.0)), u.x), u.y),\n                            mix( mix( random(i + vec3(0.0,0.0,1.0)), \n                                        random(i + vec3(1.0,0.0,1.0)), u.x),\n                                mix( random(i + vec3(0.0,1.0,1.0)), \n                                        random(i + vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\nfloat gnoise(vec3 p, float tileLength) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n            \n    vec3 u = quintic(f);\n        \n    return mix( mix( mix( dot( srandom3(i + vec3(0.0,0.0,0.0), tileLength), f - vec3(0.0,0.0,0.0)), \n                            dot( srandom3(i + vec3(1.0,0.0,0.0), tileLength), f - vec3(1.0,0.0,0.0)), u.x),\n                    mix( dot( srandom3(i + vec3(0.0,1.0,0.0), tileLength), f - vec3(0.0,1.0,0.0)), \n                            dot( srandom3(i + vec3(1.0,1.0,0.0), tileLength), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n                mix( mix( dot( srandom3(i + vec3(0.0,0.0,1.0), tileLength), f - vec3(0.0,0.0,1.0)), \n                            dot( srandom3(i + vec3(1.0,0.0,1.0), tileLength), f - vec3(1.0,0.0,1.0)), u.x),\n                    mix( dot( srandom3(i + vec3(0.0,1.0,1.0), tileLength), f - vec3(0.0,1.0,1.0)), \n                            dot( srandom3(i + vec3(1.0,1.0,1.0), tileLength), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\nvec3 gnoise3(vec3 x) {\n    return vec3(gnoise(x+vec3(123.456, 0.567, 0.37)),\n                gnoise(x+vec3(0.11, 47.43, 19.17)),\n                gnoise(x) );\n}\n\n#endif\n\n\n\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec2 permute(const in vec2 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec3 permute(const in vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(const in vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n#endif\n\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n\n\n#ifndef FNC_PSRFNOISE\n#define FNC_PSRFNOISE\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\n\t\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu = vec3(0.0);\n    vec3 iv = vec3(0.0);\n\tvec3 xw = vec3(0.0);\n    vec3 yw = vec3(0.0);\n\n\t\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { \n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t\n\tfloat n = dot(w4, gdotx);\n\n\t\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t\n\treturn 10.9 * n;\n}\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient, out vec3 dg) {\n\n\t\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\n\t\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { \n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t\n\tfloat n = dot(w4, gdotx);\n\n\t\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t\n\tvec3 dg0, dg1, dg2;\n\tvec3 dw2 = 48.0 * w2 * gdotx;\n\t\n\tdg0.xy = dw2.x * x0 * x0 - 8.0 * w3.x * (2.0 * g0 * x0 + gdotx.x);\n\tdg1.xy = dw2.y * x1 * x1 - 8.0 * w3.y * (2.0 * g1 * x1 + gdotx.y);\n\tdg2.xy = dw2.z * x2 * x2 - 8.0 * w3.z * (2.0 * g2 * x2 + gdotx.z);\n\t\n\tdg0.z = dw2.x * x0.x * x0.y - 8.0 * w3.x * dot(g0, x0.yx);\n\tdg1.z = dw2.y * x1.x * x1.y - 8.0 * w3.y * dot(g1, x1.yx);\n\tdg2.z = dw2.z * x2.x * x2.y - 8.0 * w3.z * dot(g2, x2.yx);\n\tdg = 10.9 * (dg0 + dg1 + dg2);\n\n\t\n\treturn 10.9 * n;\n}\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha) {\n    vec2 g = vec2(0.0);\n    return psrdnoise(x, period, alpha, g);\n}\n\nfloat psrdnoise(vec2 x, vec2 period) {\n    return psrdnoise(x, period, 0.0);\n}\n\nfloat psrdnoise(vec2 x) {\n    return psrdnoise(x, vec2(0.0));\n}\n\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient) {\n\n#ifndef PSRDNOISE_PERLIN_GRID\n    \n    const mat3 M = mat3(0.0, 1.0, 1.0,\n                        1.0, 0.0, 1.0,\n                        1.0, 1.0, 0.0);\n\n    const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                            0.5,-0.5, 0.5,\n                            0.5, 0.5,-0.5);\n#endif\n\n    vec3 uvw = vec3(0.0);\n\n    \n#ifndef PSRDNOISE_PERLIN_GRID\n    \n    uvw = M * x;\n #else\n    \n    \n    uvw = x + dot(x, vec3(0.33333333));\n #endif\n\n    \n    vec3 i0 = floor(uvw);\n    vec3 f0 = fract(uvw); \n\n    \n    \n    \n    \n    vec3 g_ = step(f0.xyx, f0.yzz); \n    vec3 l_ = 1.0 - g_;             \n    vec3 g = vec3(l_.z, g_.xy);\n    vec3 l = vec3(l_.xy, g_.z);\n    vec3 o1 = min( g, l );\n    vec3 o2 = max( g, l );\n\n    \n    vec3 i1 = i0 + o1;\n    vec3 i2 = i0 + o2;\n    vec3 i3 = i0 + vec3(1.0);\n\n    vec3 v0 = vec3(0.0);\n    vec3 v1 = vec3(0.0);\n    vec3 v2 = vec3(0.0);\n    vec3 v3 = vec3(0.0);\n\n    \n#ifndef PSRDNOISE_PERLIN_GRID\n    v0 = Mi * i0;\n    v1 = Mi * i1;\n    v2 = Mi * i2;\n    v3 = Mi * i3;\n#else\n    \n    v0 = i0 - dot(i0, vec3(1.0/6.0));\n    v1 = i1 - dot(i1, vec3(1.0/6.0));\n    v2 = i2 - dot(i2, vec3(1.0/6.0));\n    v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n    \n    vec3 x0 = x - v0;\n    vec3 x1 = x - v1;\n    vec3 x2 = x - v2;\n    vec3 x3 = x - v3;\n\n    if(any(greaterThan(period, vec3(0.0)))) {\n        \n        vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n        vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n        vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n        \n        if(period.x > 0.0) vx = mod(vx, period.x);\n        if(period.y > 0.0) vy = mod(vy, period.y);\n        if(period.z > 0.0) vz = mod(vz, period.z);\n        \n#ifndef PSRDNOISE_PERLIN_GRID\n        i0 = M * vec3(vx.x, vy.x, vz.x);\n        i1 = M * vec3(vx.y, vy.y, vz.y);\n        i2 = M * vec3(vx.z, vy.z, vz.z);\n        i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n        v0 = vec3(vx.x, vy.x, vz.x);\n        v1 = vec3(vx.y, vy.y, vz.y);\n        v2 = vec3(vx.z, vy.z, vz.z);\n        v3 = vec3(vx.w, vy.w, vz.w);\n        \n        i0 = v0 + dot(v0, vec3(1.0/3.0));\n        i1 = v1 + dot(v1, vec3(1.0/3.0));\n        i2 = v2 + dot(v2, vec3(1.0/3.0));\n        i3 = v3 + dot(v3, vec3(1.0/3.0));\n#endif\n        \n        i0 = floor(i0 + 0.5);\n        i1 = floor(i1 + 0.5);\n        i2 = floor(i2 + 0.5);\n        i3 = floor(i3 + 0.5);\n    }\n\n    \n    vec4 hash = permute( permute( permute( \n                vec4(i0.z, i1.z, i2.z, i3.z ))\n                + vec4(i0.y, i1.y, i2.y, i3.y ))\n                + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n    \n    vec4 theta = hash * 3.883222077;  \n    vec4 sz    = hash * -0.006920415 + 0.996539792; \n    vec4 psi   = hash * 0.108705628 ; \n\n    vec4 Ct = cos(theta);\n    vec4 St = sin(theta);\n    vec4 sz_prime = sqrt( 1.0 - sz*sz ); \n\n    vec4 gx = vec4(0.0);\n    vec4 gy = vec4(0.0);\n    vec4 gz = vec4(0.0);\n\n    \n#ifdef PSRDNOISE_FAST_ROTATION\n    \n    vec4 qx = St;         \n    vec4 qy = -Ct; \n    vec4 qz = vec4(0.0);\n\n    vec4 px =  sz * qy;   \n    vec4 py = -sz * qx;\n    vec4 pz = sz_prime;\n\n    psi += alpha;         \n    vec4 Sa = sin(psi);\n    vec4 Ca = cos(psi);\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n#else\n    \n    \n    if(alpha != 0.0) {\n        vec4 Sp = sin(psi);          \n        vec4 Cp = cos(psi);\n\n        vec4 px = Ct * sz_prime;     \n        vec4 py = St * sz_prime;     \n        vec4 pz = sz;\n\n        vec4 Ctp = St*Sp - Ct*Cp;    \n        vec4 qx = mix( Ctp*St, Sp, sz);\n        vec4 qy = mix(-Ctp*Ct, Cp, sz);\n        vec4 qz = -(py*Cp + px*Sp);\n\n        vec4 Sa = vec4(sin(alpha));       \n        vec4 Ca = vec4(cos(alpha));\n\n        gx = Ca * px + Sa * qx;\n        gy = Ca * py + Sa * qy;\n        gz = Ca * pz + Sa * qz;\n    }\n    else {\n        gx = Ct * sz_prime;  \n        gy = St * sz_prime;\n        gz = sz;  \n    }\n#endif\n\n    \n    vec3 g0 = vec3(gx.x, gy.x, gz.x);\n    vec3 g1 = vec3(gx.y, gy.y, gz.y);\n    vec3 g2 = vec3(gx.z, gy.z, gz.z);\n    vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n    \n    vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n    w = max(w, 0.0);\n    vec4 w2 = w * w;\n    vec4 w3 = w2 * w;\n\n    \n    vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n    \n    float n = dot(w3, gdotx);\n\n    \n    vec4 dw = -6.0 * w2 * gdotx;\n    vec3 dn0 = w3.x * g0 + dw.x * x0;\n    vec3 dn1 = w3.y * g1 + dw.y * x1;\n    vec3 dn2 = w3.z * g2 + dw.z * x2;\n    vec3 dn3 = w3.w * g3 + dw.w * x3;\n    gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n    \n    return 39.5 * n;\n  \n}\n\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient, out vec3 dg, out vec3 dg2) {\n\n#ifndef PSRDNOISE_PERLIN_GRID\n    \n    const mat3 M = mat3(0.0, 1.0, 1.0,\n                        1.0, 0.0, 1.0,\n                        1.0, 1.0, 0.0);\n\n    const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                            0.5,-0.5, 0.5,\n                            0.5, 0.5,-0.5);\n#endif\n\n    vec3 uvw = vec3(0.0);\n\n    \n#ifndef PSRDNOISE_PERLIN_GRID\n    \n    uvw = M * x;\n#else\n    \n    \n    uvw = x + dot(x, vec3(0.3333333));\n#endif\n\n    \n    vec3 i0 = floor(uvw);\n    vec3 f0 = fract(uvw); \n\n    \n    \n    \n    \n    vec3 g_ = step(f0.xyx, f0.yzz); \n    vec3 l_ = 1.0 - g_;             \n    vec3 g = vec3(l_.z, g_.xy);\n    vec3 l = vec3(l_.xy, g_.z);\n    vec3 o1 = min( g, l );\n    vec3 o2 = max( g, l );\n\n    \n    vec3 i1 = i0 + o1;\n    vec3 i2 = i0 + o2;\n    vec3 i3 = i0 + vec3(1.0);\n\n    vec3 v0, v1, v2, v3;\n\n    \n#ifndef PSRDNOISE_PERLIN_GRID\n    v0 = Mi * i0;\n    v1 = Mi * i1;\n    v2 = Mi * i2;\n    v3 = Mi * i3;\n#else\n    \n    v0 = i0 - dot(i0, vec3(1.0/6.0));\n    v1 = i1 - dot(i1, vec3(1.0/6.0));\n    v2 = i2 - dot(i2, vec3(1.0/6.0));\n    v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n    \n    vec3 x0 = x - v0;\n    vec3 x1 = x - v1;\n    vec3 x2 = x - v2;\n    vec3 x3 = x - v3;\n\n    if(any(greaterThan(period, vec3(0.0)))) {\n        \n        vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n        vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n        vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n        \n        if(period.x > 0.0) vx = mod(vx, period.x);\n        if(period.y > 0.0) vy = mod(vy, period.y);\n        if(period.z > 0.0) vz = mod(vz, period.z);\n        \n#ifndef PSRDNOISE_PERLIN_GRID\n        i0 = M * vec3(vx.x, vy.x, vz.x);\n        i1 = M * vec3(vx.y, vy.y, vz.y);\n        i2 = M * vec3(vx.z, vy.z, vz.z);\n        i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n        v0 = vec3(vx.x, vy.x, vz.x);\n        v1 = vec3(vx.y, vy.y, vz.y);\n        v2 = vec3(vx.z, vy.z, vz.z);\n        v3 = vec3(vx.w, vy.w, vz.w);\n        \n        i0 = v0 + dot(v0, vec3(0.3333333));\n        i1 = v1 + dot(v1, vec3(0.3333333));\n        i2 = v2 + dot(v2, vec3(0.3333333));\n        i3 = v3 + dot(v3, vec3(0.3333333));\n#endif\n        \n        i0 = floor(i0 + 0.5);\n        i1 = floor(i1 + 0.5);\n        i2 = floor(i2 + 0.5);\n        i3 = floor(i3 + 0.5);\n    }\n\n    \n    vec4 hash = permute( permute( permute( \n                vec4(i0.z, i1.z, i2.z, i3.z ))\n                + vec4(i0.y, i1.y, i2.y, i3.y ))\n                + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n    \n    vec4 theta = hash * 3.883222077;  \n    vec4 sz    = hash * -0.006920415 + 0.996539792; \n    vec4 psi   = hash * 0.108705628 ; \n\n    vec4 Ct = cos(theta);\n    vec4 St = sin(theta);\n    vec4 sz_prime = sqrt( 1.0 - sz*sz ); \n\n    vec4 gx, gy, gz;\n\n    \n#ifdef PSRDNOISE_FAST_ROTATION\n    \n    vec4 qx = St;         \n    vec4 qy = -Ct; \n    vec4 qz = vec4(0.0);\n\n    vec4 px =  sz * qy;   \n    vec4 py = -sz * qx;\n    vec4 pz = sz_prime;\n\n    psi += alpha;         \n    vec4 Sa = sin(psi);\n    vec4 Ca = cos(psi);\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n    #else\n    \n    \n    if(alpha != 0.0) {\n        vec4 Sp = sin(psi);          \n        vec4 Cp = cos(psi);\n\n        vec4 px = Ct * sz_prime;     \n        vec4 py = St * sz_prime;     \n        vec4 pz = sz;\n\n        vec4 Ctp = St*Sp - Ct*Cp;    \n        vec4 qx = mix( Ctp*St, Sp, sz);\n        vec4 qy = mix(-Ctp*Ct, Cp, sz);\n        vec4 qz = -(py*Cp + px*Sp);\n\n        vec4 Sa = vec4(sin(alpha));       \n        vec4 Ca = vec4(cos(alpha));\n\n        gx = Ca * px + Sa * qx;\n        gy = Ca * py + Sa * qy;\n        gz = Ca * pz + Sa * qz;\n    }\n    else {\n        gx = Ct * sz_prime;  \n        gy = St * sz_prime;\n        gz = sz;  \n    }\n#endif\n\n    \n    vec3 g0 = vec3(gx.x, gy.x, gz.x);\n    vec3 g1 = vec3(gx.y, gy.y, gz.y);\n    vec3 g2 = vec3(gx.z, gy.z, gz.z);\n    vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n    \n    vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n    w = max(w, 0.0);\n    vec4 w2 = w * w;\n    vec4 w3 = w2 * w;\n\n    \n    vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n    \n    float n = dot(w3, gdotx);\n\n    \n    vec4 dw = -6.0 * w2 * gdotx;\n    vec3 dn0 = w3.x * g0 + dw.x * x0;\n    vec3 dn1 = w3.y * g1 + dw.y * x1;\n    vec3 dn2 = w3.z * g2 + dw.z * x2;\n    vec3 dn3 = w3.w * g3 + dw.w * x3;\n    gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n    \n    vec4 dw2 = 24.0 * w * gdotx;\n    vec3 dga0 = dw2.x * x0 * x0 - 6.0 * w2.x * (gdotx.x + 2.0 * g0 * x0);\n    vec3 dga1 = dw2.y * x1 * x1 - 6.0 * w2.y * (gdotx.y + 2.0 * g1 * x1);\n    vec3 dga2 = dw2.z * x2 * x2 - 6.0 * w2.z * (gdotx.z + 2.0 * g2 * x2);\n    vec3 dga3 = dw2.w * x3 * x3 - 6.0 * w2.w * (gdotx.w + 2.0 * g3 * x3);\n    dg = 35.0 * (dga0 + dga1 + dga2 + dga3); \n    vec3 dgb0 = dw2.x * x0 * x0.yzx - 6.0 * w2.x * (g0 * x0.yzx + g0.yzx * x0);\n    vec3 dgb1 = dw2.y * x1 * x1.yzx - 6.0 * w2.y * (g1 * x1.yzx + g1.yzx * x1);\n    vec3 dgb2 = dw2.z * x2 * x2.yzx - 6.0 * w2.z * (g2 * x2.yzx + g2.yzx * x2);\n    vec3 dgb3 = dw2.w * x3 * x3.yzx - 6.0 * w2.w * (g3 * x3.yzx + g3.yzx * x3);\n    dg2 = 39.5 * (dgb0 + dgb1 + dgb2 + dgb3); \n\n    \n    return 39.5 * n;\n}\n\nfloat psrdnoise(vec3 x, vec3 period, float alpha) {\n    vec3 g = vec3(0.0);\n    return psrdnoise(x, period, alpha, g);\n}\n\nfloat psrdnoise(vec3 x, vec3 period) {\n    return psrdnoise(x, period, 0.0);\n}\n\nfloat psrdnoise(vec3 x) {\n    return psrdnoise(x, vec3(0.0));\n}\n#endif\n\n\n\n\n\n#ifndef RANDOM_SCALE\n#if defined(RANDOM_HIGHER_RANGE)\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#if defined(RANDOM_SINLESS)\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#if defined(RANDOM_SINLESS)\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#if defined(RANDOM_SINLESS)\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#if defined(RANDOM_SINLESS)\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy+33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\n#endif\n\n\n\n\n#ifndef FNC_WORLEY\n#define FNC_WORLEY\n\nfloat worley(vec2 p){\n    vec2 n = floor( p );\n    vec2 f = fract( p );\n\n    float dis = 1.0;\n    for( int j= -1; j <= 1; j++ )\n        for( int i=-1; i <= 1; i++ ) {\t\n                vec2  g = vec2(i,j);\n                vec2  o = random2( n + g );\n                vec2  delta = g + o - f;\n                float d = length(delta);\n                dis = min(dis,d);\n    }\n\n    return 1.0-dis;\n}\n\nfloat worley(vec3 p) {\n    vec3 n = floor( p );\n    vec3 f = fract( p );\n\n    float dis = 1.0;\n    for( int k = -1; k <= 1; k++ )\n        for( int j= -1; j <= 1; j++ )\n            for( int i=-1; i <= 1; i++ ) {\t\n                vec3  g = vec3(i,j,k);\n                vec3  o = random3( n + g );\n                vec3  delta = g+o-f;\n                float d = length(delta);\n                dis = min(dis,d);\n    }\n\n    return 1.0-dis;\n}\n\n#endif\n\n\n\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec2 permute(const in vec2 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec3 permute(const in vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(const in vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n#endif\n\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  \n                        0.366025403784439,  \n                        -0.577350269189626,  \n                        0.024390243902439); \n    \n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    \n    vec2 i1;\n    \n    \n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    \n    \n    \n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    \n    i = mod289(i); \n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    \n    \n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    \n    \n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    \n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    \n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    \n    \n    \n    \n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; \n    vec3 x3 = x0 - D.yyy;      \n\n    \n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    \n    \n    float n_ = 0.142857142857; \n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    \n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    \n    \n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    \n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  \n                        0.276393202250021,  \n                        0.414589803375032,  \n                        -0.447213595499958); \n\n    \n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); \n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    \n\n    \n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    \n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    \n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    \n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    \n    \n    \n    \n    \n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    \n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    \n    \n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    \n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec2 snoise2( vec2 x ){\n    float s  = snoise(vec2( x ));\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n\n#endif\n\n\n\n\n\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n\n\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec2 permute(const in vec2 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec3 permute(const in vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(const in vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\n#endif\n\n\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  \n                        0.366025403784439,  \n                        -0.577350269189626,  \n                        0.024390243902439); \n    \n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    \n    vec2 i1;\n    \n    \n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    \n    \n    \n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    \n    i = mod289(i); \n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    \n    \n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    \n    \n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    \n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    \n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    \n    \n    \n    \n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; \n    vec3 x3 = x0 - D.yyy;      \n\n    \n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    \n    \n    float n_ = 0.142857142857; \n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    \n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    \n    \n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    \n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  \n                        0.276393202250021,  \n                        0.414589803375032,  \n                        -0.447213595499958); \n\n    \n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); \n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    \n\n    \n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    \n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    \n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    \n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    \n    \n    \n    \n    \n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    \n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    \n    \n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    \n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec2 snoise2( vec2 x ){\n    float s  = snoise(vec2( x ));\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n\n#endif\n\n\n\n#ifndef RANDOM_SCALE\n#if defined(RANDOM_HIGHER_RANGE)\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#if defined(RANDOM_SINLESS)\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#if defined(RANDOM_SINLESS)\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#if defined(RANDOM_SINLESS)\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#if defined(RANDOM_SINLESS)\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy+33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\n#endif\n\n\n\n#ifndef FNC_SRANDOM\n#define FNC_SRANDOM\n\nfloat srandom(in float x) {\n  return -1. + 2. * fract(sin(x) * 43758.5453);\n}\n\nfloat srandom(in vec2 st) {\n  return -1. + 2. * fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat srandom(in vec3 pos) {\n  return -1. + 2. * fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfloat srandom(in vec4 pos) {\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return -1. + 2. * fract(sin(dot_product) * 43758.5453);\n}\n\nvec2 srandom2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec3 srandom3(in vec3 p) {\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(p) * 43758.5453123);\n}\n\nvec2 srandom2(in vec2 p, const in float tileLength) {\n    p = mod(p, vec2(tileLength));\n    return srandom2(p);\n}\n\nvec3 srandom3(in vec3 p, const in float tileLength) {\n    p = mod(p, vec3(tileLength));\n    return srandom3(p);\n}\n\n#endif\n\n\n#ifndef FNC_CUBIC\n#define FNC_CUBIC \nfloat cubic(const in float v) { return v*v*(3.0-2.0*v); }\nvec2  cubic(const in vec2 v)  { return v*v*(3.0-2.0*v); }\nvec3  cubic(const in vec3 v)  { return v*v*(3.0-2.0*v); }\nvec4  cubic(const in vec4 v)  { return v*v*(3.0-2.0*v); }\n\nfloat cubic(const in float value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    float value2 = value * value;\n    float value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n\nvec2 cubic(const in vec2 value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    vec2 value2 = value * value;\n    vec2 value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n\nvec3 cubic(const in vec3 value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    vec3 value2 = value * value;\n    vec3 value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n\nvec4 cubic(const in vec4 value, in float slope0, in float slope1) {\n    float a = slope0 + slope1 - 2.;\n    float b = -2. * slope0 - slope1 + 3.;\n    float c = slope0;\n    vec4 value2 = value * value;\n    vec4 value3 = value * value2;\n    return a * value3 + b * value2 + c * value;\n}\n#endif\n\n\n#ifndef FNC_QUINTIC\n#define FNC_QUINTIC \n\nfloat quintic(const in float v) { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec2  quintic(const in vec2 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec3  quintic(const in vec3 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nvec4  quintic(const in vec4 v)  { return v*v*v*(v*(v*6.0-15.0)+10.0); }\n\n#endif\n\n\n\n#ifndef FNC_GNOISE\n#define FNC_GNOISE\n\nfloat gnoise(float x) {\n    float i = floor(x);  \n    float f = fract(x);  \n    return mix(random(i), random(i + 1.0), smoothstep(0.,1.,f)); \n}\n\nfloat gnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = cubic(f);\n    return mix( a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n}\n\nfloat gnoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = quintic(f);\n    return -1.0 + 2.0 * mix( mix( mix( random(i + vec3(0.0,0.0,0.0)), \n                                        random(i + vec3(1.0,0.0,0.0)), u.x),\n                                mix( random(i + vec3(0.0,1.0,0.0)), \n                                        random(i + vec3(1.0,1.0,0.0)), u.x), u.y),\n                            mix( mix( random(i + vec3(0.0,0.0,1.0)), \n                                        random(i + vec3(1.0,0.0,1.0)), u.x),\n                                mix( random(i + vec3(0.0,1.0,1.0)), \n                                        random(i + vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\nfloat gnoise(vec3 p, float tileLength) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n            \n    vec3 u = quintic(f);\n        \n    return mix( mix( mix( dot( srandom3(i + vec3(0.0,0.0,0.0), tileLength), f - vec3(0.0,0.0,0.0)), \n                            dot( srandom3(i + vec3(1.0,0.0,0.0), tileLength), f - vec3(1.0,0.0,0.0)), u.x),\n                    mix( dot( srandom3(i + vec3(0.0,1.0,0.0), tileLength), f - vec3(0.0,1.0,0.0)), \n                            dot( srandom3(i + vec3(1.0,1.0,0.0), tileLength), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n                mix( mix( dot( srandom3(i + vec3(0.0,0.0,1.0), tileLength), f - vec3(0.0,0.0,1.0)), \n                            dot( srandom3(i + vec3(1.0,0.0,1.0), tileLength), f - vec3(1.0,0.0,1.0)), u.x),\n                    mix( dot( srandom3(i + vec3(0.0,1.0,1.0), tileLength), f - vec3(0.0,1.0,1.0)), \n                            dot( srandom3(i + vec3(1.0,1.0,1.0), tileLength), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\nvec3 gnoise3(vec3 x) {\n    return vec3(gnoise(x+vec3(123.456, 0.567, 0.37)),\n                gnoise(x+vec3(0.11, 47.43, 19.17)),\n                gnoise(x) );\n}\n\n#endif\n\n\n\n\n#ifndef FBM_OCTAVES\n#define FBM_OCTAVES 4\n#endif\n\n#ifndef FBM_NOISE_FNC\n#define FBM_NOISE_FNC(UV) snoise(UV)\n#endif\n\n#ifndef FBM_NOISE2_FNC\n#define FBM_NOISE2_FNC(UV) FBM_NOISE_FNC(UV)\n#endif\n\n#ifndef FBM_NOISE3_FNC\n#define FBM_NOISE3_FNC(UV) FBM_NOISE_FNC(UV)\n#endif\n\n#ifndef FBM_NOISE_TILABLE_FNC\n#define FBM_NOISE_TILABLE_FNC(UV, TILE) gnoise(UV, TILE)\n#endif\n\n#ifndef FBM_NOISE3_TILABLE_FNC\n#define FBM_NOISE3_TILABLE_FNC(UV, TILE) FBM_NOISE_TILABLE_FNC(UV, TILE)\n#endif\n\n#ifndef FBM_NOISE_TYPE\n#define FBM_NOISE_TYPE float\n#endif\n\n#ifndef FBM_VALUE_INITIAL\n#define FBM_VALUE_INITIAL 0.0\n#endif\n\n#ifndef FBM_SCALE_SCALAR\n#define FBM_SCALE_SCALAR 2.0\n#endif\n\n#ifndef FBM_AMPLITUD_INITIAL\n#define FBM_AMPLITUD_INITIAL 0.5\n#endif\n\n#ifndef FBM_AMPLITUD_SCALAR\n#define FBM_AMPLITUD_SCALAR 0.5\n#endif\n\n#ifndef FNC_FBM\n#define FNC_FBM\nFBM_NOISE_TYPE fbm(in vec2 st) {\n    \n    FBM_NOISE_TYPE value = FBM_NOISE_TYPE(FBM_VALUE_INITIAL);\n    float amplitud = FBM_AMPLITUD_INITIAL;\n\n    \n    for (int i = 0; i < FBM_OCTAVES; i++) {\n        value += amplitud * FBM_NOISE2_FNC(st);\n        st *= FBM_SCALE_SCALAR;\n        amplitud *= FBM_AMPLITUD_SCALAR;\n    }\n    return value;\n}\n\nFBM_NOISE_TYPE fbm(in vec3 pos) {\n    \n    FBM_NOISE_TYPE value = FBM_NOISE_TYPE(FBM_VALUE_INITIAL);\n    float amplitud = FBM_AMPLITUD_INITIAL;\n\n    \n    for (int i = 0; i < FBM_OCTAVES; i++) {\n        value += amplitud * FBM_NOISE3_FNC(pos);\n        pos *= FBM_SCALE_SCALAR;\n        amplitud *= FBM_AMPLITUD_SCALAR;\n    }\n    return value;\n}\n\nFBM_NOISE_TYPE fbm(vec3 p, float tileLength) {\n    const float persistence = 0.5;\n    const float lacunarity = 2.0;\n\n    float amplitude = 0.5;\n    FBM_NOISE_TYPE total = FBM_NOISE_TYPE(0.0);\n    float normalization = 0.0;\n\n    for (int i = 0; i < FBM_OCTAVES; ++i) {\n        float noiseValue = FBM_NOISE3_TILABLE_FNC(p, tileLength * lacunarity * 0.5) * 0.5 + 0.5;\n        total += noiseValue * amplitude;\n        normalization += amplitude;\n        amplitude *= persistence;\n        p = p * lacunarity;\n    }\n\n    return total / normalization;\n}\n#endif\n\n\n\n\n\n\nvoid main() {\n\n  vUv = uv;\n\n  \n\n  vDisplacement = fbm(position*(0.0 + 1.0/u_scale) + vec3(u_time*u_speed));\n\n  \n\n\n\n  vec3 newPosition = position + normal * vDisplacement*u_intensity;\n\n  \n\n  vec4 modelPosition = modelMatrix * vec4(newPosition, 1.0);\n\n  vec4 viewPosition = viewMatrix * modelPosition;\n\n  vec4 projectedPosition = projectionMatrix * viewPosition;\n\n\n\n  gl_Position = projectedPosition;\n\n  \n\n  //gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n  \n\n}\n\n"

const TextureMesh = () => {
  const mesh = useRef(null);
  useFrame((state) => {
    const { clock, mouse, gl, scene, camera } = state;
    if (mesh.current) {
      mesh.current.material.uniforms.u_mouse.value = [mouse.x / 2 + 0.5, mouse.y / 2 + 0.5];
      mesh.current.material.uniforms.u_time.value = clock.getElapsedTime();
      let c = gl.domElement.getBoundingClientRect();
      mesh.current.material.uniforms.u_resolution.value = [c.width, c.height];
    }
  });

  return (
    <mesh ref={mesh} position={[0, 0, 0]} scale={50} rotation={[0, 0, 0]}>
      <planeGeometry args={[1, 1, 64, 64]} />
      <shaderMaterial
        fragmentShader={fragmentShader}
        vertexShader={vertexShader}
        uniforms={{
          u_intensity: { value: 0.404 },
          u_colors: {
            value: [
              new THREE.Vector4(0.6823529411764706, 0.8509803921568627, 0.9058823529411765, 1),
              new THREE.Vector4(1, 1, 1, 1),
            ],
          },
          u_speed: { value: 0.029 },
          u_scale: { value: 0.334 },
          u_time: { value: 0 },
          u_mouse: { value: [0, 0] },
          u_resolution: { value: [64, 64] },
        }}
        wireframe={false}
        wireframeLinewidth={0}
        dithering={false}
        flatShading={true}
        side={THREE.DoubleSide}
      />
    </mesh>
  );
};

const AnimatedBackground = () => {
  return (
    <div className="fixed inset-0 z-[-1]">
      <Canvas
        gl={{
          preserveDrawingBuffer: true,
          premultipliedAlpha: false,
          alpha: true,
          transparent: true,
          antialias: true,
          precision: 'highp',
          powerPreference: 'high-performance',
        }}
        dpr={1}
        camera={{
          fov: 75,
          near: 0.1,
          far: 1000,
          position: [0, 0, 24],
        }}
      >
        <TextureMesh />
      </Canvas>
    </div>
  );
};

export default React.memo(AnimatedBackground);

// Add fragmentShader and vertexShader constants here
// (copy the shader code from the provided JSON or React component)
